//! GENERATED FILE


#ifndef __CODEGEN__

#include "physics.cpp"

static ComponentDescriptionDetails<PhysicsWorld> _reg_comp_phys_world("phys_world");
template <> int ComponentDescriptionDetails<PhysicsWorld>::ID = -1;

static ComponentDescriptionDetails<CollisionShape> _reg_comp_collision_shape("collision_shape");
template <> int ComponentDescriptionDetails<CollisionShape>::ID = -1;

static ComponentDescriptionDetails<PhysicsBody> _reg_comp_phys_body("phys_body");
template <> int ComponentDescriptionDetails<PhysicsBody>::ID = -1;

static constexpr ConstComponentDescription init_physics_collision_handler_components[] = {
  {HASH("eid"), Desc<EntityId>::Size, ComponentDescriptionFlags::kNone},
  {HASH("phys_body"), Desc<PhysicsBody>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("collision_shape"), Desc<CollisionShape>::Size, ComponentDescriptionFlags::kWrite},
};
static constexpr ConstQueryDescription init_physics_collision_handler_query_desc = {
  make_const_array(init_physics_collision_handler_components),
  empty_desc_array,
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription init_physics_body_handler_components[] = {
  {HASH("phys_body"), Desc<PhysicsBody>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
};
static constexpr ConstQueryDescription init_physics_body_handler_query_desc = {
  make_const_array(init_physics_body_handler_components),
  empty_desc_array,
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription init_physics_world_handler_components[] = {
  {HASH("phys_world"), Desc<PhysicsWorld>::Size, ComponentDescriptionFlags::kWrite},
};
static constexpr ConstQueryDescription init_physics_world_handler_query_desc = {
  make_const_array(init_physics_world_handler_components),
  empty_desc_array,
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription update_physics_components[] = {
  {HASH("phys_world"), Desc<PhysicsWorld>::Size, ComponentDescriptionFlags::kWrite},
};
static constexpr ConstQueryDescription update_physics_query_desc = {
  make_const_array(update_physics_components),
  empty_desc_array,
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription render_debug_physics_components[] = {
  {HASH("phys_world"), Desc<PhysicsWorld>::Size, ComponentDescriptionFlags::kNone},
};
static constexpr ConstQueryDescription render_debug_physics_query_desc = {
  make_const_array(render_debug_physics_components),
  empty_desc_array,
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription update_kinematic_physics_body_components[] = {
  {HASH("phys_body"), Desc<PhysicsBody>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
  {HASH("vel"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
};
static constexpr ConstQueryDescription update_kinematic_physics_body_query_desc = {
  make_const_array(update_kinematic_physics_body_components),
  empty_desc_array,
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription render_debug_player_grid_cell_components[] = {
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
  {HASH("grid_cell"), Desc<int>::Size, ComponentDescriptionFlags::kNone},
};
static constexpr ConstComponentDescription render_debug_player_grid_cell_have_components[] = {
  {HASH("user_input"), 0},
  {HASH("grid_cell"), 0},
};
static constexpr ConstComponentDescription render_debug_player_grid_cell_track_components[] = {
  {HASH("grid_cell"), Desc<bool>::Size},
};
static constexpr ConstQueryDescription render_debug_player_grid_cell_query_desc = {
  make_const_array(render_debug_player_grid_cell_components),
  make_const_array(render_debug_player_grid_cell_have_components),
  empty_desc_array,
  make_const_array(render_debug_player_grid_cell_track_components),
};

static constexpr ConstComponentDescription Brick_components[] = {
  {HASH("collision_shape"), Desc<CollisionShape>::Size, ComponentDescriptionFlags::kNone},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
};
static constexpr ConstComponentDescription Brick_have_components[] = {
  {HASH("wall"), 0},
};
static constexpr ConstQueryDescription Brick_query_desc = {
  make_const_array(Brick_components),
  make_const_array(Brick_have_components),
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription MovingBrick_components[] = {
  {HASH("collision_shape"), Desc<CollisionShape>::Size, ComponentDescriptionFlags::kNone},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
  {HASH("vel"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
};
static constexpr ConstComponentDescription MovingBrick_have_components[] = {
  {HASH("wall"), 0},
  {HASH("auto_move"), 0},
};
static constexpr ConstQueryDescription MovingBrick_query_desc = {
  make_const_array(MovingBrick_components),
  make_const_array(MovingBrick_have_components),
  empty_desc_array,
  empty_desc_array,
};
static constexpr ConstComponentDescription AliveEnemy_components[] = {
  {HASH("eid"), Desc<EntityId>::Size, ComponentDescriptionFlags::kNone},
  {HASH("collision_shape"), Desc<CollisionShape>::Size, ComponentDescriptionFlags::kNone},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
  {HASH("is_alive"), Desc<bool>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("vel"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kWrite},
};
static constexpr ConstComponentDescription AliveEnemy_have_components[] = {
  {HASH("enemy"), 0},
  {HASH("is_alive"), 0},
};
static constexpr ConstComponentDescription AliveEnemy_track_components[] = {
  {HASH("is_alive"), Desc<bool>::Size},
};
static constexpr ConstQueryDescription AliveEnemy_query_desc = {
  make_const_array(AliveEnemy_components),
  make_const_array(AliveEnemy_have_components),
  empty_desc_array,
  make_const_array(AliveEnemy_track_components),
};
static constexpr ConstComponentDescription PlayerCollision_components[] = {
  {HASH("eid"), Desc<EntityId>::Size, ComponentDescriptionFlags::kNone},
  {HASH("collision_shape"), Desc<CollisionShape>::Size, ComponentDescriptionFlags::kNone},
  {HASH("gravity"), Desc<Gravity>::Size, ComponentDescriptionFlags::kNone},
  {HASH("grid_cell"), Desc<int>::Size, ComponentDescriptionFlags::kNone},
  {HASH("jump"), Desc<Jump>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("vel"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("is_on_ground"), Desc<bool>::Size, ComponentDescriptionFlags::kWrite},
};
static constexpr ConstComponentDescription PlayerCollision_have_components[] = {
  {HASH("user_input"), 0},
  {HASH("grid_cell"), 0},
};
static constexpr ConstComponentDescription PlayerCollision_track_components[] = {
  {HASH("grid_cell"), Desc<bool>::Size},
};
static constexpr ConstQueryDescription PlayerCollision_query_desc = {
  make_const_array(PlayerCollision_components),
  make_const_array(PlayerCollision_have_components),
  empty_desc_array,
  make_const_array(PlayerCollision_track_components),
};
static constexpr ConstComponentDescription EnemyCollision_components[] = {
  {HASH("eid"), Desc<EntityId>::Size, ComponentDescriptionFlags::kNone},
  {HASH("collision_shape"), Desc<CollisionShape>::Size, ComponentDescriptionFlags::kNone},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("vel"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("dir"), Desc<float>::Size, ComponentDescriptionFlags::kWrite},
  {HASH("is_on_ground"), Desc<bool>::Size, ComponentDescriptionFlags::kWrite},
};
static constexpr ConstComponentDescription EnemyCollision_have_components[] = {
  {HASH("enemy"), 0},
  {HASH("auto_move"), 0},
  {HASH("wall_collidable"), 0},
  {HASH("is_alive"), 0},
};
static constexpr ConstComponentDescription EnemyCollision_track_components[] = {
  {HASH("is_alive"), Desc<bool>::Size},
};
static constexpr ConstQueryDescription EnemyCollision_query_desc = {
  make_const_array(EnemyCollision_components),
  make_const_array(EnemyCollision_have_components),
  empty_desc_array,
  make_const_array(EnemyCollision_track_components),
};
using BrickBuilder = StructBuilder<
  StructField<CollisionShape, INDEX_OF_COMPONENT(Brick, collision_shape)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(Brick, pos)>
>;
using MovingBrickBuilder = StructBuilder<
  StructField<CollisionShape, INDEX_OF_COMPONENT(MovingBrick, collision_shape)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(MovingBrick, pos)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(MovingBrick, vel)>
>;
using AliveEnemyBuilder = StructBuilder<
  StructField<EntityId, INDEX_OF_COMPONENT(AliveEnemy, eid)>,
  StructField<CollisionShape, INDEX_OF_COMPONENT(AliveEnemy, collision_shape)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(AliveEnemy, pos)>,
  StructField<bool, INDEX_OF_COMPONENT(AliveEnemy, is_alive)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(AliveEnemy, vel)>
>;
using PlayerCollisionBuilder = StructBuilder<
  StructField<EntityId, INDEX_OF_COMPONENT(PlayerCollision, eid)>,
  StructField<CollisionShape, INDEX_OF_COMPONENT(PlayerCollision, collision_shape)>,
  StructField<Gravity, INDEX_OF_COMPONENT(PlayerCollision, gravity)>,
  StructField<int, INDEX_OF_COMPONENT(PlayerCollision, grid_cell)>,
  StructField<Jump, INDEX_OF_COMPONENT(PlayerCollision, jump)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(PlayerCollision, pos)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(PlayerCollision, vel)>,
  StructField<bool, INDEX_OF_COMPONENT(PlayerCollision, is_on_ground)>
>;
using EnemyCollisionBuilder = StructBuilder<
  StructField<EntityId, INDEX_OF_COMPONENT(EnemyCollision, eid)>,
  StructField<CollisionShape, INDEX_OF_COMPONENT(EnemyCollision, collision_shape)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(EnemyCollision, pos)>,
  StructField<glm::vec2, INDEX_OF_COMPONENT(EnemyCollision, vel)>,
  StructField<float, INDEX_OF_COMPONENT(EnemyCollision, dir)>,
  StructField<bool, INDEX_OF_COMPONENT(EnemyCollision, is_on_ground)>
>;
static constexpr ConstComponentDescription index_by_Brick_grid_cell_components[] = {
  {HASH("collision_shape"), Desc<CollisionShape>::Size, ComponentDescriptionFlags::kNone},
  {HASH("pos"), Desc<glm::vec2>::Size, ComponentDescriptionFlags::kNone},
};
static constexpr ConstComponentDescription index_by_Brick_grid_cell_have_components[] = {
  {HASH("wall"), 0},
  {HASH("grid_cell"), 0},
};
static constexpr ConstQueryDescription index_by_Brick_grid_cell_query_desc = {
  make_const_array(index_by_Brick_grid_cell_components),
  make_const_array(index_by_Brick_grid_cell_have_components),
  empty_desc_array,
  empty_desc_array,
};

static PersistentQueryDescription _reg_query_Brick(HASH("physics.cpp_Brick"), Brick_query_desc, nullptr);
static PersistentQueryDescription _reg_query_MovingBrick(HASH("physics.cpp_MovingBrick"), MovingBrick_query_desc, nullptr);
static PersistentQueryDescription _reg_query_AliveEnemy(HASH("physics.cpp_AliveEnemy"), AliveEnemy_query_desc, 
[](const Archetype &type, int entity_idx)
{
  GET_COMPONENT_VALUE(is_alive, bool);
  return is_alive == true;
});
static PersistentQueryDescription _reg_query_PlayerCollision(HASH("physics.cpp_PlayerCollision"), PlayerCollision_query_desc, 
[](const Archetype &type, int entity_idx)
{
  GET_COMPONENT_VALUE(grid_cell, float);
  return grid_cell != -1;
});
static PersistentQueryDescription _reg_query_EnemyCollision(HASH("physics.cpp_EnemyCollision"), EnemyCollision_query_desc, 
[](const Archetype &type, int entity_idx)
{
  GET_COMPONENT_VALUE(is_alive, bool);
  return is_alive == true;
});

static IndexDescription _reg_index_index_by_Brick_grid_cell(HASH("physics.cpp_index_by_Brick_grid_cell"), HASH("grid_cell"), index_by_Brick_grid_cell_query_desc, nullptr);

int Brick::count()
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_Brick"));
  return query.entitiesCount;
}
template <typename Callable> void Brick::foreach(Callable callback)
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_Brick"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    callback(
    {
      GET_COMPONENT(Brick, q, CollisionShape, collision_shape),
      GET_COMPONENT(Brick, q, glm::vec2, pos)
    });
}
Index* Brick::index()
{
  return g_mgr->getIndexByName(HASH("physics.cpp_index_by_Brick_grid_cell"));
}
Brick Brick::get(Query::AllIterator &iter)
{
  return {
      GET_COMPONENT(Brick, iter, CollisionShape, collision_shape),
      GET_COMPONENT(Brick, iter, glm::vec2, pos)
    };
}
int MovingBrick::count()
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_MovingBrick"));
  return query.entitiesCount;
}
template <typename Callable> void MovingBrick::foreach(Callable callback)
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_MovingBrick"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    callback(
    {
      GET_COMPONENT(MovingBrick, q, CollisionShape, collision_shape),
      GET_COMPONENT(MovingBrick, q, glm::vec2, pos),
      GET_COMPONENT(MovingBrick, q, glm::vec2, vel)
    });
}
Index* MovingBrick::index()
{
  return nullptr;
}
MovingBrick MovingBrick::get(Query::AllIterator &iter)
{
  return {
      GET_COMPONENT(MovingBrick, iter, CollisionShape, collision_shape),
      GET_COMPONENT(MovingBrick, iter, glm::vec2, pos),
      GET_COMPONENT(MovingBrick, iter, glm::vec2, vel)
    };
}
int AliveEnemy::count()
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_AliveEnemy"));
  return query.entitiesCount;
}
template <typename Callable> void AliveEnemy::foreach(Callable callback)
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_AliveEnemy"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    callback(
    {
      GET_COMPONENT(AliveEnemy, q, EntityId, eid),
      GET_COMPONENT(AliveEnemy, q, CollisionShape, collision_shape),
      GET_COMPONENT(AliveEnemy, q, glm::vec2, pos),
      GET_COMPONENT(AliveEnemy, q, bool, is_alive),
      GET_COMPONENT(AliveEnemy, q, glm::vec2, vel)
    });
}
Index* AliveEnemy::index()
{
  return nullptr;
}
AliveEnemy AliveEnemy::get(Query::AllIterator &iter)
{
  return {
      GET_COMPONENT(AliveEnemy, iter, EntityId, eid),
      GET_COMPONENT(AliveEnemy, iter, CollisionShape, collision_shape),
      GET_COMPONENT(AliveEnemy, iter, glm::vec2, pos),
      GET_COMPONENT(AliveEnemy, iter, bool, is_alive),
      GET_COMPONENT(AliveEnemy, iter, glm::vec2, vel)
    };
}
int PlayerCollision::count()
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_PlayerCollision"));
  return query.entitiesCount;
}
template <typename Callable> void PlayerCollision::foreach(Callable callback)
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_PlayerCollision"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    callback(
    {
      GET_COMPONENT(PlayerCollision, q, EntityId, eid),
      GET_COMPONENT(PlayerCollision, q, CollisionShape, collision_shape),
      GET_COMPONENT(PlayerCollision, q, Gravity, gravity),
      GET_COMPONENT(PlayerCollision, q, int, grid_cell),
      GET_COMPONENT(PlayerCollision, q, Jump, jump),
      GET_COMPONENT(PlayerCollision, q, glm::vec2, pos),
      GET_COMPONENT(PlayerCollision, q, glm::vec2, vel),
      GET_COMPONENT(PlayerCollision, q, bool, is_on_ground)
    });
}
Index* PlayerCollision::index()
{
  return nullptr;
}
PlayerCollision PlayerCollision::get(Query::AllIterator &iter)
{
  return {
      GET_COMPONENT(PlayerCollision, iter, EntityId, eid),
      GET_COMPONENT(PlayerCollision, iter, CollisionShape, collision_shape),
      GET_COMPONENT(PlayerCollision, iter, Gravity, gravity),
      GET_COMPONENT(PlayerCollision, iter, int, grid_cell),
      GET_COMPONENT(PlayerCollision, iter, Jump, jump),
      GET_COMPONENT(PlayerCollision, iter, glm::vec2, pos),
      GET_COMPONENT(PlayerCollision, iter, glm::vec2, vel),
      GET_COMPONENT(PlayerCollision, iter, bool, is_on_ground)
    };
}
int EnemyCollision::count()
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_EnemyCollision"));
  return query.entitiesCount;
}
template <typename Callable> void EnemyCollision::foreach(Callable callback)
{
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_EnemyCollision"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    callback(
    {
      GET_COMPONENT(EnemyCollision, q, EntityId, eid),
      GET_COMPONENT(EnemyCollision, q, CollisionShape, collision_shape),
      GET_COMPONENT(EnemyCollision, q, glm::vec2, pos),
      GET_COMPONENT(EnemyCollision, q, glm::vec2, vel),
      GET_COMPONENT(EnemyCollision, q, float, dir),
      GET_COMPONENT(EnemyCollision, q, bool, is_on_ground)
    });
}
Index* EnemyCollision::index()
{
  return nullptr;
}
EnemyCollision EnemyCollision::get(Query::AllIterator &iter)
{
  return {
      GET_COMPONENT(EnemyCollision, iter, EntityId, eid),
      GET_COMPONENT(EnemyCollision, iter, CollisionShape, collision_shape),
      GET_COMPONENT(EnemyCollision, iter, glm::vec2, pos),
      GET_COMPONENT(EnemyCollision, iter, glm::vec2, vel),
      GET_COMPONENT(EnemyCollision, iter, float, dir),
      GET_COMPONENT(EnemyCollision, iter, bool, is_on_ground)
    };
}
static void update_player_collisions_run(const RawArg &stage_or_event, Query&)
{
  ecs::wait_system_dependencies(HASH("update_player_collisions"));
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_PlayerCollision"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    update_player_collisions::run(*(UpdateStage*)stage_or_event.mem,
    {
      GET_COMPONENT(PlayerCollision, q, EntityId, eid),
      GET_COMPONENT(PlayerCollision, q, CollisionShape, collision_shape),
      GET_COMPONENT(PlayerCollision, q, Gravity, gravity),
      GET_COMPONENT(PlayerCollision, q, int, grid_cell),
      GET_COMPONENT(PlayerCollision, q, Jump, jump),
      GET_COMPONENT(PlayerCollision, q, glm::vec2, pos),
      GET_COMPONENT(PlayerCollision, q, glm::vec2, vel),
      GET_COMPONENT(PlayerCollision, q, bool, is_on_ground)
    });
}
static SystemDescription _reg_sys_update_player_collisions(HASH("update_player_collisions"), &update_player_collisions_run, "UpdateStage");

static void update_auto_move_collisions_run(const RawArg &stage_or_event, Query&)
{
  ecs::wait_system_dependencies(HASH("update_auto_move_collisions"));
  Query &query = *g_mgr->getQueryByName(HASH("physics.cpp_EnemyCollision"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    update_auto_move_collisions::run(*(UpdateStage*)stage_or_event.mem,
    {
      GET_COMPONENT(EnemyCollision, q, EntityId, eid),
      GET_COMPONENT(EnemyCollision, q, CollisionShape, collision_shape),
      GET_COMPONENT(EnemyCollision, q, glm::vec2, pos),
      GET_COMPONENT(EnemyCollision, q, glm::vec2, vel),
      GET_COMPONENT(EnemyCollision, q, float, dir),
      GET_COMPONENT(EnemyCollision, q, bool, is_on_ground)
    });
}
static SystemDescription _reg_sys_update_auto_move_collisions(HASH("update_auto_move_collisions"), &update_auto_move_collisions_run, "UpdateStage");

static void init_physics_collision_handler_run(const RawArg &stage_or_event, Query &query)
{
  ecs::wait_system_dependencies(HASH("init_physics_collision_handler"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    init_physics_collision_handler::run(*(EventOnEntityCreate*)stage_or_event.mem,
      GET_COMPONENT(init_physics_collision_handler, q, EntityId, eid),
      GET_COMPONENT(init_physics_collision_handler, q, PhysicsBody, phys_body),
      GET_COMPONENT(init_physics_collision_handler, q, CollisionShape, collision_shape));
}
static SystemDescription _reg_sys_init_physics_collision_handler(HASH("init_physics_collision_handler"), &init_physics_collision_handler_run, "EventOnEntityCreate", init_physics_collision_handler_query_desc, nullptr);

static void init_physics_body_handler_run(const RawArg &stage_or_event, Query &query)
{
  ecs::wait_system_dependencies(HASH("init_physics_body_handler"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    init_physics_body_handler::run(*(EventOnEntityCreate*)stage_or_event.mem,
      GET_COMPONENT(init_physics_body_handler, q, PhysicsBody, phys_body),
      GET_COMPONENT(init_physics_body_handler, q, glm::vec2, pos));
}
static SystemDescription _reg_sys_init_physics_body_handler(HASH("init_physics_body_handler"), &init_physics_body_handler_run, "EventOnEntityCreate", init_physics_body_handler_query_desc, nullptr);

static void init_physics_world_handler_run(const RawArg &stage_or_event, Query &query)
{
  ecs::wait_system_dependencies(HASH("init_physics_world_handler"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    init_physics_world_handler::run(*(EventOnEntityCreate*)stage_or_event.mem,
      GET_COMPONENT(init_physics_world_handler, q, PhysicsWorld, phys_world));
}
static SystemDescription _reg_sys_init_physics_world_handler(HASH("init_physics_world_handler"), &init_physics_world_handler_run, "EventOnEntityCreate", init_physics_world_handler_query_desc, nullptr);

static void update_physics_run(const RawArg &stage_or_event, Query &query)
{
  ecs::wait_system_dependencies(HASH("update_physics"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    update_physics::run(*(UpdateStage*)stage_or_event.mem,
      GET_COMPONENT(update_physics, q, PhysicsWorld, phys_world));
}
static SystemDescription _reg_sys_update_physics(HASH("update_physics"), &update_physics_run, "UpdateStage", update_physics_query_desc, nullptr);

static void render_debug_physics_run(const RawArg &stage_or_event, Query &query)
{
  ecs::wait_system_dependencies(HASH("render_debug_physics"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    render_debug_physics::run(*(RenderDebugStage*)stage_or_event.mem,
      GET_COMPONENT(render_debug_physics, q, PhysicsWorld, phys_world));
}
static SystemDescription _reg_sys_render_debug_physics(HASH("render_debug_physics"), &render_debug_physics_run, "RenderDebugStage", render_debug_physics_query_desc, nullptr);

static void update_kinematic_physics_body_run(const RawArg &stage_or_event, Query &query)
{
  ecs::wait_system_dependencies(HASH("update_kinematic_physics_body"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    update_kinematic_physics_body::run(*(UpdateStage*)stage_or_event.mem,
      GET_COMPONENT(update_kinematic_physics_body, q, PhysicsBody, phys_body),
      GET_COMPONENT(update_kinematic_physics_body, q, glm::vec2, pos),
      GET_COMPONENT(update_kinematic_physics_body, q, glm::vec2, vel));
}
static SystemDescription _reg_sys_update_kinematic_physics_body(HASH("update_kinematic_physics_body"), &update_kinematic_physics_body_run, "UpdateStage", update_kinematic_physics_body_query_desc, nullptr);

static void render_debug_player_grid_cell_run(const RawArg &stage_or_event, Query &query)
{
  ecs::wait_system_dependencies(HASH("render_debug_player_grid_cell"));
  for (auto q = query.begin(), e = query.end(); q != e; ++q)
    render_debug_player_grid_cell::run(*(RenderDebugStage*)stage_or_event.mem,
      GET_COMPONENT(render_debug_player_grid_cell, q, glm::vec2, pos),
      GET_COMPONENT(render_debug_player_grid_cell, q, int, grid_cell));
}
static SystemDescription _reg_sys_render_debug_player_grid_cell(HASH("render_debug_player_grid_cell"), &render_debug_player_grid_cell_run, "RenderDebugStage", render_debug_player_grid_cell_query_desc, 
[](const Archetype &type, int entity_idx)
{
  GET_COMPONENT_VALUE(grid_cell, float);
  return grid_cell != -1;
});

#endif // __CODEGEN__
